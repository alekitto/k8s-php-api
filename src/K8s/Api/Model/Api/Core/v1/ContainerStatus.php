<?php

/**
 * This file was automatically generated by k8s/api-generator 0.12.0 for API version v1.27.15
 *
 * (c) Chad Sikorra <Chad.Sikorra@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

declare(strict_types=1);

namespace K8s\Api\Model\Api\Core\v1;

use K8s\Core\Annotation as Kubernetes;

/**
 * ContainerStatus contains details for the current status of this container.
 */
class ContainerStatus
{
    /**
     * @Kubernetes\Attribute("allocatedResources")
     * @var object[]|null
     */
    protected $allocatedResources = null;

    /**
     * @Kubernetes\Attribute("containerID")
     * @var string|null
     */
    protected $containerID = null;

    /**
     * @Kubernetes\Attribute("image",isRequired=true)
     * @var string
     */
    protected $image;

    /**
     * @Kubernetes\Attribute("imageID",isRequired=true)
     * @var string
     */
    protected $imageID;

    /**
     * @Kubernetes\Attribute("lastState",type="model",model=ContainerState::class)
     * @var ContainerState|null
     */
    protected $lastState = null;

    /**
     * @Kubernetes\Attribute("name",isRequired=true)
     * @var string
     */
    protected $name;

    /**
     * @Kubernetes\Attribute("ready",isRequired=true)
     * @var bool
     */
    protected $ready;

    /**
     * @Kubernetes\Attribute("resources",type="model",model=ResourceRequirements::class)
     * @var ResourceRequirements|null
     */
    protected $resources = null;

    /**
     * @Kubernetes\Attribute("restartCount",isRequired=true)
     * @var int
     */
    protected $restartCount;

    /**
     * @Kubernetes\Attribute("started")
     * @var bool|null
     */
    protected $started = null;

    /**
     * @Kubernetes\Attribute("state",type="model",model=ContainerState::class)
     * @var ContainerState|null
     */
    protected $state = null;

    /**
     * @param string $image
     * @param string $imageID
     * @param string $name
     * @param bool $ready
     * @param int $restartCount
     */
    public function __construct(string $image, string $imageID, string $name, bool $ready, int $restartCount)
    {
        $this->image = $image;
        $this->imageID = $imageID;
        $this->name = $name;
        $this->ready = $ready;
        $this->restartCount = $restartCount;
    }

    /**
     * AllocatedResources represents the compute resources allocated for this container by the node.
     * Kubelet sets this value to Container.Resources.Requests upon successful pod admission and after
     * successfully admitting desired pod resize.
     */
    public function getAllocatedResources(): ?array
    {
        return $this->allocatedResources;
    }

    /**
     * AllocatedResources represents the compute resources allocated for this container by the node.
     * Kubelet sets this value to Container.Resources.Requests upon successful pod admission and after
     * successfully admitting desired pod resize.
     *
     * @return static
     */
    public function setAllocatedResources(array $allocatedResources)
    {
        $this->allocatedResources = $allocatedResources;

        return $this;
    }

    /**
     * ContainerID is the ID of the container in the format '<type>://<container_id>'. Where type is a
     * container runtime identifier, returned from Version call of CRI API (for example "containerd").
     */
    public function getContainerID(): ?string
    {
        return $this->containerID;
    }

    /**
     * ContainerID is the ID of the container in the format '<type>://<container_id>'. Where type is a
     * container runtime identifier, returned from Version call of CRI API (for example "containerd").
     *
     * @return static
     */
    public function setContainerID(string $containerID)
    {
        $this->containerID = $containerID;

        return $this;
    }

    /**
     * Image is the name of container image that the container is running. The container image may not
     * match the image used in the PodSpec, as it may have been resolved by the runtime. More info:
     * https://kubernetes.io/docs/concepts/containers/images.
     */
    public function getImage(): string
    {
        return $this->image;
    }

    /**
     * Image is the name of container image that the container is running. The container image may not
     * match the image used in the PodSpec, as it may have been resolved by the runtime. More info:
     * https://kubernetes.io/docs/concepts/containers/images.
     *
     * @return static
     */
    public function setImage(string $image)
    {
        $this->image = $image;

        return $this;
    }

    /**
     * ImageID is the image ID of the container's image. The image ID may not match the image ID of the
     * image used in the PodSpec, as it may have been resolved by the runtime.
     */
    public function getImageID(): string
    {
        return $this->imageID;
    }

    /**
     * ImageID is the image ID of the container's image. The image ID may not match the image ID of the
     * image used in the PodSpec, as it may have been resolved by the runtime.
     *
     * @return static
     */
    public function setImageID(string $imageID)
    {
        $this->imageID = $imageID;

        return $this;
    }

    /**
     * LastTerminationState holds the last termination state of the container to help debug container
     * crashes and restarts. This field is not populated if the container is still running and RestartCount
     * is 0.
     */
    public function getLastState(): ?ContainerState
    {
        return $this->lastState;
    }

    /**
     * LastTerminationState holds the last termination state of the container to help debug container
     * crashes and restarts. This field is not populated if the container is still running and RestartCount
     * is 0.
     *
     * @return static
     */
    public function setLastState(ContainerState $lastState)
    {
        $this->lastState = $lastState;

        return $this;
    }

    /**
     * Name is a DNS_LABEL representing the unique name of the container. Each container in a pod must have
     * a unique name across all container types. Cannot be updated.
     */
    public function getName(): string
    {
        return $this->name;
    }

    /**
     * Name is a DNS_LABEL representing the unique name of the container. Each container in a pod must have
     * a unique name across all container types. Cannot be updated.
     *
     * @return static
     */
    public function setName(string $name)
    {
        $this->name = $name;

        return $this;
    }

    /**
     * Ready specifies whether the container is currently passing its readiness check. The value will
     * change as readiness probes keep executing. If no readiness probes are specified, this field defaults
     * to true once the container is fully started (see Started field).
     *
     * The value is typically used to determine whether a container is ready to accept traffic.
     */
    public function isReady(): bool
    {
        return $this->ready;
    }

    /**
     * Ready specifies whether the container is currently passing its readiness check. The value will
     * change as readiness probes keep executing. If no readiness probes are specified, this field defaults
     * to true once the container is fully started (see Started field).
     *
     * The value is typically used to determine whether a container is ready to accept traffic.
     *
     * @return static
     */
    public function setIsReady(bool $ready)
    {
        $this->ready = $ready;

        return $this;
    }

    /**
     * Resources represents the compute resource requests and limits that have been successfully enacted on
     * the running container after it has been started or has been successfully resized.
     */
    public function getResources(): ?ResourceRequirements
    {
        return $this->resources;
    }

    /**
     * Resources represents the compute resource requests and limits that have been successfully enacted on
     * the running container after it has been started or has been successfully resized.
     *
     * @return static
     */
    public function setResources(ResourceRequirements $resources)
    {
        $this->resources = $resources;

        return $this;
    }

    /**
     * RestartCount holds the number of times the container has been restarted. Kubelet makes an effort to
     * always increment the value, but there are cases when the state may be lost due to node restarts and
     * then the value may be reset to 0. The value is never negative.
     */
    public function getRestartCount(): int
    {
        return $this->restartCount;
    }

    /**
     * RestartCount holds the number of times the container has been restarted. Kubelet makes an effort to
     * always increment the value, but there are cases when the state may be lost due to node restarts and
     * then the value may be reset to 0. The value is never negative.
     *
     * @return static
     */
    public function setRestartCount(int $restartCount)
    {
        $this->restartCount = $restartCount;

        return $this;
    }

    /**
     * Started indicates whether the container has finished its postStart lifecycle hook and passed its
     * startup probe. Initialized as false, becomes true after startupProbe is considered successful.
     * Resets to false when the container is restarted, or if kubelet loses state temporarily. In both
     * cases, startup probes will run again. Is always true when no startupProbe is defined and container
     * is running and has passed the postStart lifecycle hook. The null value must be treated the same as
     * false.
     */
    public function isStarted(): ?bool
    {
        return $this->started;
    }

    /**
     * Started indicates whether the container has finished its postStart lifecycle hook and passed its
     * startup probe. Initialized as false, becomes true after startupProbe is considered successful.
     * Resets to false when the container is restarted, or if kubelet loses state temporarily. In both
     * cases, startup probes will run again. Is always true when no startupProbe is defined and container
     * is running and has passed the postStart lifecycle hook. The null value must be treated the same as
     * false.
     *
     * @return static
     */
    public function setIsStarted(bool $started)
    {
        $this->started = $started;

        return $this;
    }

    /**
     * State holds details about the container's current condition.
     */
    public function getState(): ?ContainerState
    {
        return $this->state;
    }

    /**
     * State holds details about the container's current condition.
     *
     * @return static
     */
    public function setState(ContainerState $state)
    {
        $this->state = $state;

        return $this;
    }
}
